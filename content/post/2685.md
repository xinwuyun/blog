+++
title = "Flask 到 Gin —— SQLAlchemy 和 gorm"
postid = 2685
date = 2020-01-05T11:24:14+08:00
isCJKLanguage = true
toc = true
type = "post"
slug = "flask-to-gin-sqlalchemy-gorm"
aliases = [ "/post/2685.html",]
category = [ "technology",]
tag = [ "fromto", "flask", "golang", "python", "gin", "mjp", "sqlalchemy"]
+++

本文是 [从 Flask 到 Gin](/post/flask-to-gin-index/) 系列的第 4 篇。

----

本篇讲解在 Flask 和 Gin 中使用 MySQL 数据库的相关问题。在 Flask 中，我使用的是 Python 世界中最强大的 [ORM][orm] 库： [SQLAlchemy][sa]。在 Gin 的实现中，我选择了 [gorm][gorm]。<!--more-->

Golang 中的 ORM 也是百花齐放的状态，如果你不喜欢 gorm ，也可以参考 [awsome-go](https://awesome-go.com/#orm) 来选择。

## SQLAlchemy 的表定义

我博客中写过几篇关于 [SQLAlchemy](/tag/sqlalchemy/) 的文章。在 Flask 的项目中，我使用的是 [FlaskSQLAlchemy][flasksa] 这个插件，它对 SQLAlchemy 进行了简单的封装。

在我的项目中，连接了一个名为 `data1` 的数据库，这个数据库中有两个表，名为 `active` 和 `register`，下方的代码展示了这两个表在 SQLAlchemy 中的定义：

``` python
# -*- coding: utf-8 -*-
"""
app.models.audible
~~~~~~~~~~~~~~~~~~~

data1.active
data2.register
"""

# db 就是 flask_sqlalchemy.SQLAlchemy 的实例
from mjp.app import db


class LogActive(db.Model):
    """ Log 中的活跃数据
    """
    __tablename__ = 'active'
    __bind_key__ = 'data1'

    # 就是 regional
    gid = db.Column(db.INT, primary_key=True, index=True)

    # 代表日期
    date = db.Column(db.INT, primary_key=True, index=True)

    # 渠道 ID
    channel = db.Column(db.INT, primary_key=True, index=True)

    # 数量
    num = db.Column(db.INT, nullable=True)


class LogRegister(db.Model):
    """ Log 中的注册数据
    """
    __tablename__ = 'register'
    __bind_key__ = 'data2'

    # 就是 regional
    gid = db.Column(db.INT, primary_key=True, index=True)

    # 代表日期
    date = db.Column(db.INT, primary_key=True, index=True)

    # 渠道 ID
    channel = db.Column(db.INT, primary_key=True, index=True)

    # 数量
    num = db.Column(db.INT, nullable=True)
```

在 SQLAlchemy 中，可以很灵活的使用参数语法来制定表字段的定义。也可以使用 `__tablename__` 来指定表名，使用 `__bind_key__` 来指定这个表对应的数据库。

上面两个表的结构是一致的，它们的内容如下所示：

![data2.register](/uploads/2020/01/register.png)

对应的多数据库配置，默认的数据库指向 data1。这意味着如果不在 class 定义中指定 `__bind_key__`，则会认为这个表是位于 data1：

``` python
{
    "SECRET_KEY": "YutjgVSPDERGyPayXrXbwsuF_SZWiVmUw3mD4YYD_kY=",
    "SQLALCHEMY_DATABASE_URI": "mysql+pymysql://zrong:123456@127.0.0.1/data1",
    "SQLALCHEMY_BINDS": {
        "data1": "mysql+pymysql://zrong:123456@127.0.0.1/data1",
        "data2": "mysql+pymysql://zrong:123456@127.0.0.1/data2"
    }
}
```

## SQLAlchemy 中的多数据库查询

由于 `data1.active` 和 `data2.register` 这两个表的结构是一样的，我将其封装成同一个方法： `_response_register_or_active`，通过传入不同的表定义来实现查询。下面代码中的 `responseto` 方法的定义已经在 [从 Flask 到 Gin —— 处理 JSON][flask2gin1] 一文中介绍过了。

``` python
def _parse_date(datestr):
    if datestr is None:
        return None
    return int(dt.strftime('%Y%m%d'))


def _response_register_or_active(DataTable):
    """ 提供一个数据表作为参数，数据表的字段名称必须相同
    返回一个响应对象
    :param DataTable: 数据表 Class

    :arg from_date: 起始日期
    :arg to_date: 终止日期
    """
    # get_request_values 是一个获取查询的封装，等同于在 request.args 中查询，很容易实现，在此就不列出定义了
    gids, from_date, to_date = get_request_values('pftype', 'gids', 'from_date', 'to_date', request_key='args')
    from_date = _parse_date(from_date)
    to_date = _parse_date(to_date)
    if from_date is None or to_date is None or gids is None:
        return responseto('请提供 from_date/to_date/gids!', code=401)
    try:
        gids = json.loads(gids)
        if not isinstance(gids, list) or len(gids) == 0:
            return responseto('gids 必须是一个列表！', code=401)
    except Exception as e:
        return responseto('gids 解析错误！', code=401)

    gids = [item.r for item in rall]
    results = DataTable.query.\
        filter(DataTable.gid.in_(gids)).\
        filter(and_(DataTable.date >= from_date, DataTable.date <= to_date)).\
        with_entities(DataTable.gid, DataTable.date, func.sum(DataTable.num).label('num')).\
        group_by(DataTable.gid, DataTable.date).\
        all()
    stat = [{
                'gid': item.gid,
                'num': int(item.num),
                'date': item.date
            } for item in results]
    return responseto(stat=stat, gids=gids)
```

定义两个不同的路由，直接调用上面的 `_response_register_or_active` 就可以实现根据提供的日期分组返回 MySQL 中的数据：

``` python
@audible.route('/register/', methods=['GET'])
def register():
    """ 获取注册数据
    """
    return _response_register_or_active(LogRegister)


@audible.route('/active/', methods=['GET'])
def active():
    """ 获取活跃数据
    """
    return _response_register_or_active(LogActive)
```

在对 LogRegister 和 LogActive 这两个表进行定义的时候，我们已经通过 `__bind_key__` 指定了数据库，执行查询的时候，SQLAlchemy 会自行切换数据库进行查询。

让我们来测试一下：

``` shell
curl --request GET \
  --url 'http://127.0.0.1:5001/audible/register/?from_date=20180801&to_date=20180802&gids=%5B1%2C53%5D'
```

结果为：

``` json
{
  "code": 200,
  "error": false,
  "gids": [
    1,
    53
  ],
  "stat": [
    {
      "date": 20180801,
      "gid": 1,
      "num": 819
    },
    {
      "date": 20180802,
      "gid": 1,
      "num": 840
    },
    {
      "date": 20180801,
      "gid": 53,
      "num": 680
    },
    {
      "date": 20180802,
      "gid": 53,
      "num": 624
    }
  ]
}
```

## gorm 的表定义

## gorm 中的多数据库查询

----


阅读系列所有文章：[从 Flask 到 Gin](/post/flask-to-gin-index/)。

{{<label 全文完 info>}}

[orm]: https://en.wikipedia.org/wiki/Object-relational_mapping
[sa]: https://www.sqlalchemy.org/
[gorm]: https://gorm.io
[flasksa]: https://flask-sqlalchemy.palletsprojects.com/
[flask2gin1]: /post/flask-to-gin-json/